#include <iostream>
#include <vector>
//#include "vector.h"
using namespace std;

// ------------------------------------------ //
// Вектор - как динамический массив. Но умеет гораздо больше - например, сам умеет работать с памятью +
// не нужны дополнительные операции при добавлении / удалении элемента из массива.
// Вектор работает по шаблону => надо в <> скобках указать тип, с которым планируем работать.
// ------------------------------------------ //

// ------------------------ Методы ------------------------ //
// 0. Метод size - возвращает количество элементов в векторе
// 1. Метод push_back - чтобы добавить элемент в конец массива
// Метод clear - очистить вектор от всех элементов
// Метод pop_back - удаляет последний элемент в векторе

// Метод capacity - изначально кажется, что он похож на метод size, но это не так.
// Size - это фактическое значение количества добавленных элементов в вектор.
// Capacity - это значение, которое будет вычислено с помощью дополнительного коэффициента (+ оно зависит от количества
// элементов в векторе). Оно не всегда будет совпадать со значением метода Size.
// Почему?
// При добавлении нового элемента в динамический массив мы должны создать новый массив (но с +1 ячейкой для нашего нового значения),
// затем мы должны переложить все элементы из старого массива в новый, добавить новый элемент в конец и указатель в памяти, который указывал на старый массив,
// переопределить на новый массив.
// НО в векторе это реализовано иначе. При добавлении нового элемента в массив, память под новый массив выделяется с запасом (т.е. не всегда +1 ячейка).
// Таким образом, при вызове метода capacity мы можем получить большее значение, чем при вызове метода size.
// Т.е. пока есть свободное capacity, то при добавлении нового элемента не будет создаваться новый массив, а будет заполняться
// то свободное место, что у нас еще есть.

// Метод reserve - сразу выделяет такое capacity, какое хочет пользователь (myVector.reserve(100)) - сразу будет создан массив на 100 элементов
// Метод shrink_to_fit - подгоняет размер capacity под size (фактическое количество элементов в векторе)

// ---- Конструкторы ----
// myVector(20) - создаст вектор с двадцатью элементами (все они будут = 0). При этом capacity и size будут = тоже 20.
// myVector(20, 55) - создаст вектор с двадцатью элементами (все они будут = 55).
// ---- Конструкторы ----

// Метод empty - проверка на то, есть ли в нашем векторе элементы (возвращает true/false)

// Метод resize - аналогично конструктору (myVector.resize(20), myVector.resize(20,55))

// Метод insert - вставка элемента в любое место в векторе (используется с помощью итераторов)
// Метод erase - удаление элемента в любое место в векторе (используется с помощью итераторов)

int main() {
    // Вектор работает по шаблону => надо в <> скобках указать тип, с которым планируем работать
    vector<int> myVector(-10);
    cout << "size " << myVector.size() << endl;
    cout << "capacity " << myVector.capacity() << endl;
//    myVector.push_back(2);
//    myVector.push_back(32);
//    myVector.push_back(14);
//    myVector.push_back(99);

    for (int i = 0; i < myVector.size(); i++) {
        cout << myVector[i] << " ";
    }
    cout << endl;
    cout << "size " << myVector.size() << endl;
    cout << "capacity " << myVector.capacity() << endl;
//----------//
//    s21::vector<int> newVector;
//    newVector();
//    cout << "size " << myVector.size() << endl;
//    cout << "capacity " << myVector.capacity() << endl;

//    vector<int>::iterator i = myVector.begin();

    return 0;
}